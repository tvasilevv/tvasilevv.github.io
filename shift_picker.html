import logging
import sqlite3
import json
from datetime import datetime
import calendar
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    CallbackQueryHandler,
    filters
)

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)


def init_db():
    conn = sqlite3.connect('schedules.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS schedules (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            schedule TEXT
        )
    ''')
    conn.commit()
    conn.close()


def save_schedule(user_id: int, username: str, schedule: dict):
    conn = sqlite3.connect('schedules.db')
    cursor = conn.cursor()
    cursor.execute(
        "INSERT OR REPLACE INTO schedules (user_id, username, schedule) VALUES (?, ?, ?)",
        (user_id, username, json.dumps(schedule, ensure_ascii=False))
    )
    conn.commit()
    conn.close()


def load_schedule(user_id: int) -> dict:
    conn = sqlite3.connect('schedules.db')
    cursor = conn.cursor()
    cursor.execute("SELECT schedule FROM schedules WHERE user_id = ?", (user_id,))
    row = cursor.fetchone()
    conn.close()
    if row and row[0]:
        try:
            return json.loads(row[0])
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –¥–ª—è {user_id}: {e}")
            return {}
    return {}


def get_main_menu():
    keyboard = [
        ["üìÖ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–∞—Ç—ã", "üë• –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è"],
        ["üóìÔ∏è –ú–æ–π –≥—Ä–∞—Ñ–∏–∫", "üßπ –û—á–∏—Å—Ç–∏—Ç—å –¥–∞–Ω–Ω—ã–µ"]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)


def create_calendar(user_data, year=None, month=None):
    now = datetime.now()
    if year is None:
        year = now.year
    if month is None:
        month = now.month

    schedule = user_data.get('schedule', {})
    selected_dates = set(schedule.keys())

    keyboard = [
        [
            InlineKeyboardButton("¬´", callback_data=f"cal-prev-{year}-{month}"),
            InlineKeyboardButton(f"{calendar.month_name[month]} {year}", callback_data="ignore"),
            InlineKeyboardButton("¬ª", callback_data=f"cal-next-{year}-{month}")
        ],
        [InlineKeyboardButton(day, callback_data="ignore") for day in ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]]
    ]

    cal = calendar.monthcalendar(year, month)
    for week in cal:
        row = []
        for day in week:
            if day == 0:
                row.append(InlineKeyboardButton(" ", callback_data="ignore"))
            else:
                date_str = f"{year}-{month:02d}-{day:02d}"
                text = f"‚úÖ{day}" if date_str in selected_dates else str(day)
                row.append(InlineKeyboardButton(text, callback_data=f"cal-day-{date_str}"))
        keyboard.append(row)

    keyboard.append([InlineKeyboardButton("‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data="cal-done")])
    return InlineKeyboardMarkup(keyboard)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–ü—Ä–∏–≤–µ—Ç! üëã –Ø –ø–æ–º–æ–≥—É –Ω–∞–π—Ç–∏ –∫–æ–ª–ª–µ–≥ —Å —Å–æ–≤–ø–∞–¥–∞—é—â–∏–º–∏ —Ä–∞–±–æ—á–∏–º–∏ –¥–Ω—è–º–∏.\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=get_main_menu()
    )


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    text = update.message.text.strip()

    if text == "üìÖ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–∞—Ç—ã":
        context.user_data['schedule'] = {}
        await update.message.reply_text(
            "–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—ã –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ:",
            reply_markup=create_calendar(context.user_data)
        )
    elif text == "üë• –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è":
        await show_matches(update, user)
    elif text == "üóìÔ∏è –ú–æ–π –≥—Ä–∞—Ñ–∏–∫":
        await show_my_schedule(update, user)
    elif text == "üßπ –û—á–∏—Å—Ç–∏—Ç—å –¥–∞–Ω–Ω—ã–µ":
        conn = sqlite3.connect('schedules.db')
        cursor = conn.cursor()
        cursor.execute("DELETE FROM schedules WHERE user_id = ?", (user.id,))
        conn.commit()
        conn.close()
        await update.message.reply_text("‚úÖ –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ —É–¥–∞–ª–µ–Ω—ã.")
    else:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é.")


async def show_my_schedule(update: Update, user):
    schedule = load_schedule(user.id)
    if not schedule:
        await update.message.reply_text("–í—ã –µ—â—ë –Ω–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ —Å–≤–æ–π –≥—Ä–∞—Ñ–∏–∫. –ù–∞–∂–º–∏—Ç–µ üìÖ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–∞—Ç—ã.")
        return

    lines = []
    for date_str in sorted(schedule.keys()):
        try:
            nice_date = datetime.strptime(date_str, "%Y-%m-%d").strftime("%d.%m.%Y")
        except:
            nice_date = date_str
        lines.append(f"{nice_date}: {schedule[date_str]}")
    await update.message.reply_text("üóìÔ∏è –í–∞—à –≥—Ä–∞—Ñ–∏–∫:\n\n" + "\n".join(lines))


async def show_matches(update: Update, user):
    my_schedule = load_schedule(user.id)
    if not my_schedule:
        await update.message.reply_text("–°–Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–≤–æ–π –≥—Ä–∞—Ñ–∏–∫!")
        return

    my_dates = set(my_schedule.keys())

    conn = sqlite3.connect('schedules.db')
    cursor = conn.cursor()
    cursor.execute("SELECT user_id, username, schedule FROM schedules WHERE user_id != ?", (user.id,))
    others = cursor.fetchall()
    conn.close()

    date_to_users = {}

    for _, username, schedule_json in others:
        if not schedule_json:
            continue
        try:
            other_schedule = json.loads(schedule_json)
        except:
            continue
        other_dates = set(other_schedule.keys())
        common_dates = my_dates & other_dates
        for d in common_dates:
            if d not in date_to_users:
                date_to_users[d] = []
            display_name = f"@{username}" if username and not username.startswith("user_") else f"user_{_}"
            shift_time = other_schedule[d]
            date_to_users[d].append(f"{display_name} ({shift_time})")

    if not date_to_users:
        await update.message.reply_text("–ü–æ–∫–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π –Ω–µ—Ç. –ü–æ–ø—Ä–æ—Å–∏—Ç–µ –∫–æ–ª–ª–µ–≥ –¥–æ–±–∞–≤–∏—Ç—å –≥—Ä–∞—Ñ–∏–∫!")
        return

    msg = "üìÖ –°–æ–≤–ø–∞–¥–∞—é—â–∏–µ –¥–Ω–∏:\n\n"
    for d in sorted(date_to_users.keys()):
        try:
            nice_date = datetime.strptime(d, "%Y-%m-%d").strftime("%d.%m.%Y")
        except:
            nice_date = d
        users_list = ", ".join(sorted(date_to_users[d]))
        msg += f"üìÜ <b>{nice_date}</b>:\n   üë§ {users_list}\n\n"

    await update.message.reply_text(msg, parse_mode="HTML")


async def handle_calendar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data

    if data == "ignore":
        return

    if data.startswith("cal-prev-") or data.startswith("cal-next-"):
        parts = data.split("-")
        year, month = int(parts[2]), int(parts[3])
        if data.startswith("cal-prev-"):
            if month == 1:
                year -= 1
                month = 12
            else:
                month -= 1
        else:
            if month == 12:
                year += 1
                month = 1
            else:
                month += 1
        await query.edit_message_reply_markup(
            reply_markup=create_calendar(context.user_data, year, month)
        )

    elif data.startswith("cal-day-"):
        date_str = data.split("-", 2)[2]
        context.user_data['pending_date'] = date_str

        WEB_APP_URL = "https://tvasilevv.github.io/shift_picker.html"

        keyboard = [
            [InlineKeyboardButton("üïó –£–∫–∞–∑–∞—Ç—å –≤—Ä–µ–º—è —Å–º–µ–Ω—ã", web_app=WebAppInfo(url=WEB_APP_URL))],
            [InlineKeyboardButton("¬´ –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –∫–∞–ª–µ–Ω–¥–∞—Ä—é", callback_data=f"cal-back-{date_str}")]
        ]
        await query.edit_message_text(
            text=f"üìÜ –í—ã–±—Ä–∞–Ω–∞ –¥–∞—Ç–∞: {date_str}\n–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å –≤—Ä–µ–º—è:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    elif data.startswith("cal-back-"):
        date_str = data.split("-", 2)[2]
        y, m, _ = map(int, date_str.split("-"))
        await query.edit_message_text(
            "–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—ã –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ:",
            reply_markup=create_calendar(context.user_data, y, m)
        )

    elif data == "cal-done":
        schedule = context.user_data.get('schedule', {})
        if not schedule:
            await query.edit_message_text("‚ùå –í—ã –Ω–µ –¥–æ–±–∞–≤–∏–ª–∏ –Ω–∏ –æ–¥–Ω–æ–π —Å–º–µ–Ω—ã.")
            return

        user = update.effective_user
        save_schedule(user.id, user.username or f"user_{user.id}", schedule)
        await query.edit_message_text(
            f"‚úÖ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ {len(schedule)} —Å–º–µ–Ω!\n"
            f"–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –Ω–∞–∂–∞—Ç—å üë• –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –∏–ª–∏ üóìÔ∏è –ú–æ–π –≥—Ä–∞—Ñ–∏–∫."
        )


async def handle_web_app_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    try:
        data = json.loads(update.message.web_app_data.data)
        start = data["start"]
        end = data["end"]
        shift_time = f"{start}‚Äì{end}"
    except Exception as e:
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –≤ –¥–∞–Ω–Ω—ã—Ö –≤—Ä–µ–º–µ–Ω–∏.")
        logger.error(f"WebApp error: {e}")
        return

    date_str = context.user_data.get('pending_date')
    if not date_str:
        await update.message.reply_text("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–∞—Ç–∞ –¥–ª—è —Å–º–µ–Ω—ã.")
        return

    schedule = context.user_data.setdefault('schedule', {})
    schedule[date_str] = shift_time

    y, m, _ = map(int, date_str.split("-"))
    await update.message.reply_text(
        f"‚úÖ –°–º–µ–Ω–∞ –Ω–∞ {date_str} —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞:\n{shift_time}",
        reply_markup=create_calendar(context.user_data, y, m)
    )
    context.user_data.pop('pending_date', None)


def main():
    init_db()
    TOKEN = "8437477599:AAFcAe6M1upQ44iFfXYFqElsMCOQj8cpb_Y"

    app = Application.builder().token(TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    app.add_handler(CallbackQueryHandler(handle_calendar))
    app.add_handler(MessageHandler(filters.StatusUpdate.WEB_APP_DATA, handle_web_app_data))

    print("‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω...")
    app.run_polling()


if __name__ == '__main__':
    main()
